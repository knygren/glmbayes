% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rnorm_reg.R
\name{rnorm_reg}
\alias{rnorm_reg}
\alias{rnorm_reg_cpp}
\title{The Bayesian Normal Regression Distribution}
\usage{
rnorm_reg(n = 1, y, x, mu, P, wt = 1, dispersion = 1, offset2 = NULL)
}
\arguments{
\item{n}{number of draws to generate. If \code{length(n) > 1}, the length is taken to be the number required.}

\item{y}{a vector of observations of length \code{m}.}

\item{x}{a design matrix of dimension \code{m * p}.}

\item{mu}{a vector of length \code{p} giving the prior means of the variables in the design matrix.}

\item{P}{a positive-definite symmetric matrix of dimension \code{p * p} specifying the prior precision matrix of the variable.}

\item{wt}{an optional vector of \sQuote{prior weights} to be used in the fitting process. Should be NULL or a numeric vector.}

\item{dispersion}{the dispersion parameter. Either a single numerical value or NULL (the default). Must be provided here. Use \code{\link{rnorm_gamma_reg}} or Block-Gibbs sampling using \code{\link{rglmb_dispersion}} to give the dispersion a prior.}

\item{offset2}{this can be used to specify an \emph{a priori} known component to be included in the linear predictor during fitting. This should be \code{NULL} or a numeric vector of length equal to the number of cases. One or more offset terms can be included in the formula instead or as well, and if more than one is specified their sum is used. See \code{\link{model.offset}}.}
}
\value{
\code{rnorm_reg} returns a object of class \code{"rglmb"}.  The function \code{summary} 
(i.e., \code{\link{summary.rglmb}}) can be used to obtain or print a summary of the results.
The generic accessor functions \code{\link{coefficients}}, \code{\link{fitted.values}},
\code{\link{residuals}}, and \code{\link{extractAIC}} can be used to extract
various useful features of the value returned by \code{\link{rglmb}}.
An object of class \code{"rglmb"} is a list containing at least the following components:
\item{coefficients}{a \code{n} by \code{length(mu)} matrix with one sample in each row}
\item{PostMode}{a vector of \code{length(mu)} with the estimated posterior mode coefficients}
\item{Prior}{A list with two components. The first being the prior mean vector and the second the prior precision matrix}
\item{iters}{an \code{n} by \code{1} matrix giving the number of candidates generated before acceptance for each sample.}
\item{famfunc}{an object of class \code{"famfunc"}}
\item{Envelope}{an object of class \code{"envelope"}  }
\item{dispersion}{the dispersion parameter used in the model}
\item{loglike}{a \code{n} by \code{1} matrix containing the negative loglikelihood for each sample.}
}
\description{
\code{rnorm_reg} is used to generate iid samples from Bayesian linear models with a normal prior. 
The model is specified by providing a data vector, a design matrix, and 2 prior constants.
}
\details{
The \code{rnorm_reg} function produces iid samples for Bayesian linear 
models with a multivariate normal prior. Core required inputs for the function include the data vector, the design  
matrix and a prior specification. In addition, the dispersion parameter must 
currently be provided.The function returns the simulated Bayesian coefficients 
and some associated outputs. The iid samples from the posterior density are genererated using 
standard simulation procedures for multivariate normal densities.
}
\examples{
data(menarche)

summary(menarche)
plot(Menarche/Total ~ Age, data=menarche)

Age2=menarche$Age-13

x<-matrix(as.numeric(1.0),nrow=length(Age2),ncol=2)
x[,2]=Age2

y=menarche$Menarche/menarche$Total
wt=menarche$Total

mu<-matrix(as.numeric(0.0),nrow=2,ncol=1)
mu[2,1]=(log(0.9/0.1)-log(0.5/0.5))/3

V1<-1*diag(as.numeric(2.0))

# 2 standard deviations for prior estimate at age 13 between 0.1 and 0.9
## Specifies uncertainty around the point estimates

V1[1,1]<-((log(0.9/0.1)-log(0.5/0.5))/2)^2 
V1[2,2]=(3*mu[2,1]/2)^2  # Allows slope to be up to 3 times as large as point estimate 

out<-rglmb(n = 1000, y=y, x=x, mu=mu, P=solve(V1), wt = wt, 
           family = binomial(logit), Gridtype = 3) 
summary(out)

mean(out$iters)
}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmb.wfit.R
\name{glmb.wfit}
\alias{glmb.wfit}
\title{Fitter Function for Bayesian Generalized Linear Models}
\usage{
glmb.wfit(
  x,
  y,
  weights = rep.int(1, nobs),
  offset = rep.int(0, nobs),
  family = gaussian(),
  Bbar,
  P,
  betastar,
  method = "qr",
  tol = 1e-07,
  singular.ok = TRUE,
  ...
)
}
\arguments{
\item{x}{design matrix of dimension \code{n * p}.}

\item{y}{vector of observations of length \code{n}, or a matrix with
    \code{n} rows.}

\item{weights}{an optional vector of \emph{prior weights} to be used in the fitting process. 
Should be \code{NULL} or a numeric vector.}

\item{offset}{(numeric of length \code{n}).  This can be used to
    specify an \emph{a priori} known component to be included in the
    linear predictor during fitting.}

\item{family}{a description of the error distribution and link function to be used in the model.
Should be a family function. (see \code{\link{family}} for details of family functions.)}

\item{Bbar}{Prior mean vector of length \code{p}.}

\item{P}{Prior precision matrix of dimension \code{p * p}.}

\item{betastar}{Posterior mode vector of length \code{p} which has already been estimated.}

\item{method}{currently, only \code{method = "qr"} is supported.}

\item{tol}{tolerance for the \code{\link{qr}} decomposition.  Default
    is 1e-7.}

\item{singular.ok}{logical. If \code{FALSE}, a singular model is an
    error.}

\item{...}{currently disregarded.}
}
\value{
a \code{\link{list}} wih components:
}
\description{
Basic computing engine called to replicate the output from the lm.fit function for an already
optimized Bayesian Generalized Linear model.
}
\examples{
set.seed(333)
## Dobson (1990) Page 93: Randomized Controlled Trial :
counts <- c(18,17,15,20,10,20,25,13,12)
outcome <- gl(3,1,9)
treatment <- gl(3,3)
mysd<-1
mu<-matrix(0,5)
mu[1]=log(mean(counts))
V0<-((mysd)^2)*diag(5)
glmb.D93<-glmb(counts ~ outcome + treatment, family = poisson(),pfamily=dNormal(mu=mu,Sigma=V0))

##### Try calling lm.fit using posterior mode from model to see if the optimized mode gets returned back

## Start setup here [First output from earlier optim optimization]
betastar=glmb.D93$coef.mode  # Posterior mode from optim
x=glmb.D93$x
y=glmb.D93$y
#offset=glmb.D93$offset   # not present in the output --> For now set to 0 vector
offset2=0*y   # Should return this from lower level functions
weights2=glmb.D93$prior.weights

## Check influence measures for original model
fit=glmb.wfit(x,y,weights2,offset2,family=poisson(),Bbar=mu,P=solve(V0),betastar)
influence.measures(fit)

print(fit)
print(glmb.D93$coef.mode)

### Now try a strong prior with poorly chosen intercept
mu1=0*mu
V1=0.1*V0
glmb2.D93<-glmb(counts ~ outcome + treatment, family = poisson(),pfamily=dNormal(mu=mu1,Sigma=V1))

Bbar2=mu1  # Prior mean
betastar2=glmb2.D93$coef.mode  # Posterior mode from optim
fit2=glmb.wfit(x,y,weights2,offset2,family=poisson(),Bbar2,P=solve(V1),betastar2)

influence.measures(fit2)

print(fit2)
print(glmb2.D93$coef.mode)


#glmb2.D93$qr=glmb2.D93$fit$qr


influence.measures(glmb2.D93$fit,influence(glmb2.D93))

influence.measures.glmb(glmb2.D93,influence(glmb2.D93))


#rstandard(glmb2.D93,influence(glmb2.D93))
#rstudent(glmb2.D93,influence(glmb2.D93))
dfbetas(glmb2.D93,influence(glmb2.D93))
dfbeta(glmb2.D93,influence(glmb2.D93))
hatvalues(glmb2.D93,influence(glmb2.D93))
#cooks.distance(glmb2.D93,influence(glmb2.D93))

#covratio(glmb2.D93,influence(glmb2.D93))
#dffits(glmb2.D93,influence(glmb2.D93))

dffits(glmb2.D93$fit,influence(glmb2.D93))
cooks.distance(glmb2.D93$fit,influence(glmb2.D93))
covratio(glmb2.D93$fit,influence(glmb2.D93))
#hat(glmb2.D93$fit,influence(glmb2.D93))


influence.measures.glmb(glmb2.D93,influence(glmb2.D93))


influence.measures.glmb(glmb2.D93,influence(glmb2.D93))

influence.measures(glmb2.D93$fit,influence(glmb2.D93))
}

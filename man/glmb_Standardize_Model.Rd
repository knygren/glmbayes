% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glmb_Standardize_Model.R
\name{glmb_Standardize_Model}
\alias{glmb_Standardize_Model}
\title{Standardize A Non-Gaussian Model}
\usage{
glmb_Standardize_Model(y, x, P, bstar, A1)
}
\arguments{
\item{y}{a vector of observations of length m}

\item{x}{a design matrix of dimension m*p}

\item{P}{a positive-definite symmetric matrix specifying the prior precision matrix of the variables.}

\item{bstar}{a matrix containing the posterior mode from an optimization step}

\item{A1}{a matrix containing the posterior precision matrix at the posterior mode}
}
\value{
A list with the following components
\item{bstar2}{Standardized Posterior Mode}
\item{A}{Standardized Data Precision Matrix}
\item{x2}{Standardized Design Matrix}
\item{mu2}{Standardized Prior Mean vector}
\item{P2}{Standardized Precision Matrix Added to log-likelihood}
\item{L2Inv}{A matrix used when undoing the first step in standardization described below}
\item{L3Inv}{A matrix used when undoing the second step in standardization described below}
}
\description{
Standardizes a Non-Gaussian Model prior to Envelope Creation
}
\details{
This functions starts with basic information about the model in the argument list and then
uses the following steps to further standardize the model (the model is already assumed to have a 0 prior mean vector
when this step is applied).

1) An eigenvalue composition is applied to the posterior precision matrix, and the model is (as an interim step)
standardized to have a posterior precision matrix equal to the identity matrix. Please note that this means
that the prior precision matrix after this step is \code{"smaller"} than the identity matrix.


2) A diagonal matrix epsilon is pulled out from the standardized prior precision matrix so that the remaining
part of the prior precision matrix still is positive definite. That part is then treated as part of the posterior
for the rest of the standardization and simulation and only the part connected to epsilon is treated as part of the prior. 
Note that the exact epsilon chosen seems not to matter. Hence there are many possible ways of doing this 
standardization and future versions of this package may tweak the current approach 
if it helps improve numerical accuracy or acceptance rates.


3) The model is next standardized (using a second eigenvalue decomposition) so that the prior (i.e., the portion connected to epsilon) is the identity 
matrix. The standardized model then simutaneously has the feature that the prior precision matrix is the 
identity matrix and that the data precision A (at the posterior mode) is a diagonal matrix. Hence the variables
in the standardized model are approximately independent at the posterior mode.
}
\examples{
data(menarche2)

summary(menarche2)
plot(Menarche/Total ~ Age, data=menarche2)

Age2=menarche2$Age-13

x<-matrix(as.numeric(1.0),nrow=length(Age2),ncol=2)
x[,2]=Age2

y=menarche2$Menarche/menarche2$Total
wt=menarche2$Total

mu<-matrix(as.numeric(0.0),nrow=2,ncol=1)
mu[2,1]=(log(0.9/0.1)-log(0.5/0.5))/3

V1<-1*diag(as.numeric(2.0))

# 2 standard deviations for prior estimate at age 13 between 0.1 and 0.9
## Specifies uncertainty around the point estimates

V1[1,1]<-((log(0.9/0.1)-log(0.5/0.5))/2)^2 
V1[2,2]=(3*mu[2,1]/2)^2  # Allows slope to be up to 1 times as large as point estimate 

famfunc<-glmbfamfunc(binomial(logit))

f1<-famfunc$f1
f2<-famfunc$f2
f3<-famfunc$f3
f5<-famfunc$f5
f6<-famfunc$f6

dispersion2<-as.numeric(1.0)
start <- mu
offset2=rep(as.numeric(0.0),length(y))
P=solve(V1)
n=1000

## Appears that the type for some of these arguments are important/problematic



###### Adjust weight for dispersion

wt2=wt/dispersion2

######################### Shift mean vector to offset so that adjusted model has 0 mean

alpha=x\%*\%as.vector(mu)+offset2
mu2=0*as.vector(mu)
P2=P
x2=x


#####  Optimization step to find posterior mode and associated Precision

parin=start-mu

opt_out=optim(parin,f2,f3,y=as.vector(y),x=as.matrix(x),mu=as.vector(mu2),
              P=as.matrix(P),alpha=as.vector(alpha),wt=as.vector(wt2),
              method="BFGS",hessian=TRUE
)

bstar=opt_out$par  ## Posterior mode for adjusted model
bstar
bstar+as.vector(mu)  # mode for actual model
A1=opt_out$hessian # Approximate Precision at mode

## Standardize Model

Standard_Mod=glmb_Standardize_Model(y=as.vector(y), x=as.matrix(x),P=as.matrix(P),
                                    bstar=as.matrix(bstar,ncol=1), A1=as.matrix(A1))

bstar2=Standard_Mod$bstar2  
A=Standard_Mod$A
x2=Standard_Mod$x2
mu2=Standard_Mod$mu2
P2=Standard_Mod$P2
L2Inv=Standard_Mod$L2Inv
L3Inv=Standard_Mod$L3Inv
}
\keyword{internal}
